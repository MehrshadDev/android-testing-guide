
                <!DOCTYPE html>
                <html lang="fa" dir="rtl">
                <head>
                    <meta charset="UTF-8">
                    <meta name="viewport" content="width=device-width, initial-scale=1.0">
                    <title>تست‌های رابط کاربری (UI Test) و یکپارچه‌سازی در جت‌پک کامپوز</title>
                    <link href="https://fonts.googleapis.com/css2?family=Vazirmatn:wght@100..900&display=swap" rel="stylesheet">
                    <style>
                        body {
                            font-family: 'Vazirmatn', sans-serif;
                            line-height: 1.8;
                            padding: 2rem;
                            max-width: 900px;
                            margin: 0 auto;
                            color: #333;
                            text-align: justify;
                        }
                        h1, h2, h3 {
                            border-bottom: 2px solid #a7f3d0;
                            padding-bottom: 0.5rem;
                            margin-top: 2.5rem;
                            margin-bottom: 1.5rem;
                            color: #047857;
                            text-align: right;
                        }
                        h1 { font-size: 2rem; }
                        h2 { font-size: 1.75rem; }
                        h3 { font-size: 1.5rem; }
                        p { margin-bottom: 1rem; }
                        pre {
                            background-color: #f4f4f4;
                            border: 1px solid #ddd;
                            padding: 1rem;
                            border-radius: 4px;
                            overflow-x: auto;
                            direction: ltr;
                            text-align: left;
                            font-size: 0.9rem;
                            font-family: monospace;
                        }
                        ul, ol {
                            margin-right: 1.5rem;
                            padding-right: 0;
                            margin-bottom: 1rem;
                        }
                        ul li { list-style-type: disc; margin-bottom: 0.5rem; }
                        strong { color: #065f46; }
                        .document-title { 
                            text-align: center; 
                            margin-bottom: 3rem; 
                            color: #059669;
                            font-size: 2.5rem;
                            font-weight: 800;
                        }
                    </style>
                </head>
                <body>
                    <nav>
                          <a href="index.html">صفحه اصلی</a> |
                          <a href="2.html">مقاله شماره ۲</a> |
                          <a href="3.html">مقاله شماره ۳</a> |
                          <a href="4.html">مقاله شماره ۴</a>
                    </nav>
                    <div class="document-title">تست‌های رابط کاربری (UI Test) و یکپارچه‌سازی در جت‌پک کامپوز</div>
                    
                            <p>تست‌های رابط کاربری (UI Test) و یکپارچه‌سازی در جت‌پک کامپوز: دروازه‌ای به اطمینان از تجربه کاربری<br><em></em>*</p><p></p><h2>مقدمه: چرا تست UI در کامپوز متفاوت است؟</h2><p></p><p>تست رابط کاربری (UI Testing) یکی از حیاتی‌ترین بخش‌های تضمین کیفیت در توسعه نرم‌افزار است. در اکوسیستم سنتی اندروید (مبتنی بر View)، توسعه‌دهندگان عمدتاً از Espresso برای تعامل با عناصر مبتنی بر شناسه (IDs) استفاده می‌کردند.</p><p>اما جت‌پک کامپوز (Jetpack Compose) با تغییر پارادایم از رابط کاربری دستوری (Imperative) به اعلانی (Declarative)، روش تست‌نویسی را نیز متحول کرده است. در کامپوز، تمرکز از یافتن ویو بر اساس ID برداشته شده و به سمت <strong>سمانتیک (Semantics)</strong> یا معنای عناصر معطوف می‌شود. این یعنی ما به جای پرسیدن "آیا دکمه با شناسه <code>btn_login</code> وجود دارد؟"، می‌پرسیم "آیا عنصری با محتوای 'ورود' یا 'توضیحات محتوای (Content Description)' 'دکمه ورود' وجود دارد؟"</p><p>این تغییر، تست‌های ما را قابل اطمینان‌تر، قابل خواندن‌تر و نزدیک‌تر به تجربه کاربری واقعی می‌کند.</p><p>این سرفصل، شما را از نصب وابستگی‌های اولیه تا نوشتن تست‌های یکپارچه‌سازی پیچیده در معماری MVI با استفاده از Compose Testing Framework راهنمایی می‌کند.</p><p>---</p><p></p><h2>۱. آماده‌سازی محیط و وابستگی‌های لازم</h2><p></p><p>برای شروع تست‌های UI در کامپوز، باید وابستگی‌های مرتبط را به فایل <code>build.gradle.kts (module level)</code> اضافه کنید. این وابستگی‌ها باید در بخش <code>androidTestImplementation</code> قرار گیرند.</p><p></p><pre><code class="language-kotlin">// build.gradle.kts (module level)<p></p><p>dependencies {<br>    // هسته جت‌پک کامپوز و JUnit<br>    androidTestImplementation("androidx.compose.ui:ui-test-junit4")<br>    // اگر از Hilt برای تزریق استفاده می‌کنید (مباحث پیشرفته‌تر)<br>    // androidTestImplementation("com.google.dagger:hilt-android-testing:X.Y.Z")</p><p>    // مانیفست تست و ابزارهای مورد نیاز برای اجرای تست<br>    debugImplementation("androidx.compose.ui:ui-test-manifest") </p></code><p><code class="language-kotlin">    // برای استفاده از ActivityTestRule (که توصیه می‌شود)<br>    androidTestImplementation("androidx.test.ext:junit:1.1.5")<br>    androidTestImplementation("androidx.test.espresso:espresso-core:3.5.1")<br>}</code></p></pre><p></p><p><strong>نکته مهم در مورد Manifest:</strong> وابستگی <code>ui-test-manifest</code> باید حتماً با <code>debugImplementation</code> اضافه شود تا فقط در بیلد Debug در دسترس باشد و به حجم نسخه نهایی برنامه اضافه نشود.</p><p>---</p><p></p><h2>۲. مبانی API تست کامپوز (ComposeTestRule)</h2><p></p><p>قلب تست‌نویسی UI در کامپوز، <code>ComposeTestRule</code> است. این قانون به ما اجازه می‌دهد تا محیط رندر کامپوز را کنترل کرده و با عناصر درون آن تعامل کنیم.</p><p>ما معمولاً از یکی از دو قانون زیر استفاده می‌کنیم:</p><p></p><h3>الف. <code>createComposeRule()</code></h3><p></p><p>این قانون یک محیط کامپوز خالی ایجاد می‌کند و برای تست کامپوزبل‌های کوچک و منفرد که نیازی به منابع اندروید (مانند Context، تصاویر، ریسورس‌های Activity) ندارند، مناسب است.</p><p></p><h3>ب. <code>createAndroidComposeRule<t: activity="">()</t:></code></h3><p></p><p>این قانون یک <code>Activity</code> مشخص را راه‌اندازی می‌کند (اغلب <code>ComponentActivity</code> یا اکتیویتی اصلی برنامه شما). این بهترین گزینه برای تست‌های یکپارچه‌سازی یا زمانی است که کامپوزبل شما به منابع سیستمی نیاز دارد.</p><p></p><pre><code class="language-kotlin">// مثال استفاده از AndroidComposeRule<br>class LoginScreenTest {<br>    @get:Rule<br>    val composeTestRule = createAndroidComposeRule<mainactivity>() // اکتیویتی خود را تعیین کنید<p></p><p>    @Test<br>    fun loginScreen_initialState_displaysCorrectly() {<br>        // ۱. بارگذاری کامپوزبل مورد نظر در داخل اکتیویتی<br>        composeTestRule.setContent {<br>            MyApplicationTheme {<br>                LoginScreen( /<em> پارامترهای لازم </em>/ ) <br>            }<br>        }</p></mainactivity></code><p><code class="language-kotlin">        // ۲. شروع تعاملات و اعتبارسنجی<br>        // ...<br>    }<br>}</code></p></pre><p></p><p>---</p><p></p><h2>۳. گردش کار تست: پیدا کردن، عمل کردن، اعتبارسنجی (Locate, Act, Assert)</h2><p></p><p>تست‌های کامپوز از یک الگوی ساده پیروی می‌کنند:</p><p></p><h3>الف. پیدا کردن عناصر (Locate - Matchers)</h3><p></p><p>این مرحله حیاتی‌ترین بخش است، زیرا ما باید عنصر مورد نظر را بر اساس سمانتیک آن پیدا کنیم.</p><p>| متد Matcher | کاربرد | مثال |<br>| :--- | :--- | :--- |<br>| <code>onNodeWithText()</code> | پیدا کردن بر اساس متن قابل نمایش برای کاربر (مهم برای برچسب‌ها و دکمه‌ها) | <code>onNodeWithText("ورود")</code> |<br>| <code>onNodeWithContentDescription()</code> | پیدا کردن بر اساس توضیحات محتوا (برای عناصر غیرمتنی مانند آیکون‌ها) | <code>onNodeWithContentDescription("جستجو")</code> |<br>| <code>onNodeWithTag()</code> | پیدا کردن بر اساس تگ تست (بهترین روش برای عناصر داخلی که کاربر نمی‌بیند) | <code>onNodeWithTag("EmailInput")</code> |<br>| <code>onNode(matcher)</code> | استفاده از یک مشخصه سمانتیک عمومی | <code>onNode(hasClickAction())</code> |</p><p><strong>اولویت‌بندی در یافتن عناصر:</strong><br>برای اینکه تست‌ها پایدارتر باشند، اولویت زیر توصیه می‌شود:</p><p></p><ul><br><li><strong><code>onNodeWithTag()</code>:</strong> برای عناصر کنترلی داخلی که نباید متنشان تغییر کند (مانند فیلدهای ورودی).</li><p></p><p></p><li><strong><code>onNodeWithContentDescription()</code>:</strong> برای آیکون‌ها و تصاویر.</li><p></p><p></p><li><strong><code>onNodeWithText()</code>:</strong> برای دکمه‌ها و متونی که کاربر مستقیماً با آن‌ها تعامل دارد.</li><p></p><p>برای استفاده از <code>onNodeWithTag()</code>، باید تگ را در داخل کامپوزبل با استفاده از <code>Modifier</code> تعریف کنید:</p><p></p><pre><code class="language-kotlin">// داخل کامپوزبل<br>TextField(<br>    value = email, <br>    onValueChange = { email = it },<br>    modifier = Modifier.testTag("EmailInput") // تعریف تگ تست<br>)</code></pre><p></p><p></p><h3>ب. انجام عمل (Act - Performers)</h3><p></p><p>پس از پیدا کردن عنصر، می‌توانیم با آن تعامل کنیم:</p><p>| متد Performer | کاربرد |<br>| :--- | :--- |<br>| <code>.performClick()</code> | شبیه‌سازی کلیک ماوس یا لمس |<br>| <code>.performTextInput("...")</code> | وارد کردن متن به یک فیلد ورودی |<br>| <code>.performScrollTo()</code> | اسکرول کردن تا عنصر مورد نظر نمایان شود |<br>| <code>.performTextReplacement("...")</code> | جایگزین کردن کل متن موجود در فیلد |</p><p></p><h3>ج. اعتبارسنجی (Assert - Assertions)</h3><p></p><p>در نهایت، باید مطمئن شویم که حالت رابط کاربری پس از تعاملات ما به درستی تغییر کرده است:</p><p>| متد Assertion | کاربرد |<br>| :--- | :--- |<br>| <code>.assertIsDisplayed()</code> | بررسی می‌کند که عنصر در حال نمایش است. |<br>| <code>.assertDoesNotExist()</code> | بررسی می‌کند که عنصر از درخت سمانتیک حذف شده است. |<br>| <code>.assertTextEquals("...")</code> | محتوای متنی عنصر را بررسی می‌کند. |<br>| <code>.assertIsEnabled()</code> / <code>.assertIsNotEnabled()</code> | بررسی می‌کند که عنصر فعال است یا خیر. |<br>| <code>.assertIsFocused()</code> | بررسی می‌کند که عنصر در وضعیت فوکوس است. |</p><p>---</p><p></p><h2>۴. مثال جامع عملی: تست فرم ورود</h2><p></p><p>فرض کنید یک صفحه ورود ساده داریم که ایمیل و رمز عبور می‌گیرد و پس از کلیک بر روی دکمه، یک پیام موفقیت نمایش می‌دهد.</p><p></p><pre><code class="language-kotlin">// فرض کنید این کامپوزبل تست شده است (با تگ‌های لازم)<br>@Composable<br>fun LoginScreen(viewModel: LoginViewModel) { /<em> ... </em>/ }<p></p><p>class LoginScreenUITest {</p><p>    @get:Rule<br>    val composeTestRule = createAndroidComposeRule<mainactivity>()<br>    // ۱. تزریق یک ViewModel Mock یا Fakes برای کنترل حالت (اگر از Hilt استفاده نمی‌کنید)<br>    private val fakeViewModel = FakeLoginViewModel()</mainactivity></p><p>    @Before<br>    fun setup() {<br>        composeTestRule.setContent {<br>            MyApplicationTheme {<br>                // اگر از Hilt استفاده نمی‌کنید، اینجا ViewModel را تزریق کنید<br>                LoginScreen(viewModel = fakeViewModel) <br>            }<br>        }<br>    }</p><p>    @Test<br>    fun loginFlow_withValidCredentials_showsSuccessMessage() {<br>        // گام ۱: پیدا کردن فیلدهای ورودی و وارد کردن داده‌ها<br>        composeTestRule.onNodeWithTag("EmailInput")<br>            .performTextInput("test@example.com")<br>        composeTestRule.onNodeWithTag("PasswordInput")<br>            .performTextInput("123456")</p><p>        // گام ۲: کلیک بر روی دکمه ورود<br>        composeTestRule.onNodeWithText("ورود")<br>            .assertIsEnabled() // مطمئن می‌شویم که دکمه فعال است<br>            .performClick()</p><p>        // (نکته: در MVI، ViewModel باید پس از کلیک، حالت موفقیت را ارسال کند.)<br>        // گام ۳: اعتبارسنجی پیام موفقیت<br>        // فرض می‌کنیم پس از موفقیت، یک متن "عملیات با موفقیت انجام شد" نمایش داده می‌شود.<br>        composeTestRule.onNodeWithText("عملیات با موفقیت انجام شد")<br>            .assertIsDisplayed()<br>        // همچنین مطمئن می‌شویم دکمه دیگر فعال نیست (اگر UI اینطور طراحی شده باشد)<br>        composeTestRule.onNodeWithText("ورود")<br>            .assertIsNotEnabled() <br>    }</p></code><p><code class="language-kotlin">    @Test<br>    fun loginFlow_emptyFields_buttonIsDisabled() {<br>        // از ابتدا مطمئن می‌شویم که دکمه ورود (قبل از وارد کردن هر متنی) غیرفعال است<br>        composeTestRule.onNodeWithText("ورود")<br>            .assertIsNotEnabled()<br>            .assertIsDisplayed() <br>    }<br>}</code></p></pre><p></p><p>---</p><p></p><h2>۵. تست‌های یکپارچه‌سازی (Integration Testing) و معماری MVI</h2><p></p><p>تست‌های یکپارچه‌سازی در کامپوز بر خلاف یونیت تست‌ها، تمرکز بر روی یک Composable منفرد ندارند؛ بلکه بر روی تعامل صحیح بین چندین بخش از سیستم (Composable، ViewModel، Repository و State) تمرکز می‌کنند.</p><p>در معماری MVI (Model-View-Intent)، تست UI ما باید موارد زیر را پوشش دهد:</p><p><br></p><li> <strong>ارسال Intent:</strong> آیا تعامل کاربر (مثلاً کلیک) به درستی به Intent تبدیل شده و به ViewModel ارسال می‌شود؟</li><p></p><p></p><li> <strong>تغییر State:</strong> آیا ViewModel با دریافت Intent، State را به درستی به‌روزرسانی می‌کند؟</li><p></p><p></p><li> <strong>بازتاب UI:</strong> آیا UI با دریافت State جدید، خود را به درستی رندر می‌کند؟</li><br></ul><p></p><p></p><h3>تکنیک‌های کلیدی برای یکپارچه‌سازی MVI</h3><p></p><p>#### الف. کنترل محیط Coroutine</p><p>اکثر ViewModels مدرن از Coroutines برای انجام عملیات ناهمگام (مانند فراخوانی شبکه) استفاده می‌کنند. برای پایدارسازی تست‌ها، باید اجرای Coroutine را تحت کنترل بگیریم.</p><p>در تست‌های اندروید، معمولاً باید <code>Dispatchers.Main</code> را برای اجرای سریع و همزمان عملیات ناهمگام جایگزین کنیم:</p><p></p><pre><code class="language-kotlin">// تعریف TestRule برای Coroutines<br>@get:Rule<br>val coroutineRule = MainDispatcherRule() // این یک کلاس سفارشی است که Dispatchers.Main را عوض می‌کند<p></p><p>// مثال MainDispatcherRule:<br>class MainDispatcherRule(<br>    private val testDispatcher: TestDispatcher = StandardTestDispatcher()<br>) : TestWatcher() {<br>    override fun starting(description: Description) {<br>        Dispatchers.setMain(testDispatcher)<br>    }</p></code><p><code class="language-kotlin">    override fun finished(description: Description) {<br>        Dispatchers.resetMain()<br>    }<br>}</code></p></pre><p></p><p>با تنظیم این قانون، می‌توانیم مطمئن شویم که وقتی ViewModel یک State را منتشر می‌کند (حتی اگر در Coroutine باشد)، UI بلافاصله آن را دریافت می‌کند و تست ما ناهمزمان نمی‌شود.</p><p>#### ب. تست حالت‌های بارگذاری (Loading States)</p><p>تست کنید که وقتی کاربر یک عملیات را آغاز می‌کند (مانند کلیک بر روی دکمه ورود)، UI به درستی حالت <code>Loading</code> را نمایش می‌دهد (مثلاً نمایش یک <code>CircularProgressIndicator</code>).</p><p></p><pre><code class="language-kotlin">@Test<br>fun loginFlow_showsLoadingState_thenSuccess() {<br>    // مرحله ۱: کلیک برای ارسال Intent<br>    composeTestRule.onNodeWithText("ورود").performClick()<p></p><p>    // فرض کنید ViewModel بلافاصله به حالت Loading می‌رود<br>    // ما باید یک گره با Content Description="در حال بارگذاری" را چک کنیم<br>    composeTestRule.onNodeWithContentDescription("در حال بارگذاری")<br>        .assertIsDisplayed()</p><p>    // (شبیه‌سازی موفقیت‌آمیز بودن عملیات توسط ViewModel Fake/Mock)<br>    fakeViewModel.simulateSuccess() </p></code><p><code class="language-kotlin">    // مرحله ۲: اعتبارسنجی نمایش حالت Success و حذف Loading<br>    composeTestRule.onNodeWithText("عملیات با موفقیت انجام شد")<br>        .assertIsDisplayed()<br>    composeTestRule.onNodeWithContentDescription("در حال بارگذاری")<br>        .assertDoesNotExist()<br>}</code></p></pre><p></p><p>---</p><p></p><h2>۶. مدیریت زمان و تأخیر در کامپوز (Synchronization)</h2><p></p><p>کامپوز در تست‌نویسی بسیار سریع عمل می‌کند و معمولاً نیاز به <code>Thread.sleep()</code> یا <code>IdlingResource</code>های سنتی ندارد. با این حال، گاهی اوقات باید منتظر تغییرات خاصی در درخت UI بمانیم.</p><p></p><h3>استفاده از <code>waitUntil</code></h3><p></p><p>اگر یک عملیات ناهمگام دارید که ممکن است چند میلی‌ثانیه طول بکشد تا UI را به‌روزرسانی کند، از توابع انتظار صریح استفاده کنید:</p><p></p><pre><code class="language-kotlin">// منتظر بمانید تا عنصر با این متن در UI ظاهر شود (حداکثر 1 ثانیه)<br>composeTestRule.waitUntil(timeoutMillis = 1000) {<br>    composeTestRule.onNodeWithText("داده‌های بارگذاری شده")<br>        .fetchSemanticsNode().isDisplayed<br>}<p></p></code><p><code class="language-kotlin">composeTestRule.onNodeWithText("داده‌های بارگذاری شده").assertIsDisplayed()</code></p></pre><br><strong>نکته:</strong> اگر از <code>TestDispatcher</code>ها برای کنترل Coroutineها در ViewModel خود استفاده می‌کنید، معمولاً نیازی به <code>waitUntil</code> نخواهید داشت، زیرا می‌توانید به‌صورت دستی عملیات <code>advanceUntilIdle()</code> را فراخوانی کنید تا تمام کارها در صف اجرا شوند.<p></p><p>---</p><p></p><h2>۷. نکات پیشرفته و بهترین شیوه‌ها (Best Practices)</h2><p></p><p>برای نوشتن تست‌های UI پایدار، تمیز و قابل نگهداری در کامپوز، اصول زیر را رعایت کنید:</p><p></p><h3>۱. استفاده انحصاری از <code>TestTag</code> برای عناصر داخلی</h3><p></p><p>از <code>TestTag</code> فقط برای عناصری استفاده کنید که <strong>ضروری نیستند که برای کاربر خوانا باشند</strong> (مانند کانتینرها، آیکون‌هایی که <code>ContentDescription</code> ندارند، یا فیلدهای ورودی).</p><p><strong>چرا؟</strong> اگر از <code>onNodeWithText()</code> استفاده کنید و طراحان تصمیم بگیرند متن دکمه "ثبت" را به "تأیید" تغییر دهند، تست شما خراب می‌شود. در حالی که این تغییر منطقی است، شکست تست غیرضروری است. با استفاده از تگ‌های تست داخلی، UI می‌تواند تغییر کند بدون اینکه تست‌های شما شکسته شوند.</p><p></p><h3>۲. اولویت دادن به Accessibility</h3><p></p><p>هنگامی که عنصری متنی نیست (مانند یک آیکون)، حتماً از <code>ContentDescription</code> استفاده کنید. این نه تنها برای دسترس‌پذیری ضروری است، بلکه ابزار تست کامپوز از آن به عنوان یک <code>Matcher</code> قدرتمند استفاده می‌کند.</p><p></p><pre><code class="language-kotlin">Icon(<br>    imageVector = Icons.Default.Search,<br>    contentDescription = "دکمه جستجو", // این به عنوان Matcher استفاده می‌شود<br>    // ...<br>)</code></pre><p></p><p></p><h3>۳. محدود کردن Scope تست (Focus Testing)</h3><p></p><p>تست‌های UI باید بر روی قرارداد (Contract) کامپوزبل تمرکز کنند:<br>*   چه چیزی را به عنوان ورودی می‌گیرند (State)?<br>*   چه چیزی را خروجی می‌دهند (Intents یا کلیک‌ها)?</p><p>از تست کردن جزئیات پیاده‌سازی داخلی کامپوزبل‌ها اجتناب کنید. به عنوان مثال، نباید نحوه محاسبه حاشیه (Padding) یک عنصر را تست کنید؛ فقط ظاهر شدن یا ناپدید شدن آن را تست کنید.</p><p></p><h3>۴. استفاده از Semantics Tree Viewer</h3><p></p><p>ابزار تست کامپوز، درخت سمانتیک (Semantics Tree) را ایجاد می‌کند که نشان می‌دهد عناصر از دید تست‌فریم‌ورک چگونه دیده می‌شوند. اگر نمی‌توانید عنصری را پیدا کنید، می‌توانید با استفاده از متد زیر در تست خود، درخت سمانتیک را در کنسول (logcat) چاپ کنید تا متوجه شوید Matcher شما دقیقاً به دنبال چه چیزی است:</p><p></p><pre><code class="language-kotlin">// این خط را برای دیباگ در هر نقطه از تست قرار دهید<br>composeTestRule.onRoot().printToLog("SemanticsTree")</code></pre><p></p><p></p><h3>۵. تست بر روی Activity نه فقط Composable</h3><p></p><p>همیشه توصیه می‌شود که برای تست‌های یکپارچه‌سازی از <code>createAndroidComposeRule</code> استفاده کنید، حتی اگر فقط یک Composable کوچک را تست می‌کنید، زیرا این کار باعث می‌شود منابع تم، Context و فونت‌ها به‌درستی بارگذاری شوند و از خطاهای رندر جلوگیری شود.</p><p>---</p><p></p><h2>نتیجه‌گیری</h2><p></p><p>تست‌های رابط کاربری در جت‌پک کامپوز، به دلیل تکیه بر سمانتیک به جای شناسه‌های داخلی، قوی‌تر و خواناتر از روش‌های سنتی هستند. با تسلط بر <code>ComposeTestRule</code>، استفاده استراتژیک از <code>TestTag</code>ها، و کنترل دقیق محیط Coroutine (برای یکپارچه‌سازی MVI)، می‌توانید اطمینان حاصل کنید که رابط کاربری شما نه تنها زیباست، بلکه تحت سخت‌ترین سناریوهای کاربری نیز پایدار باقی می‌ماند. تست‌های یکپارچه‌سازی، پل مطمئنی بین منطق تجاری (ViewModel) و ارائه بصری (Composable) ایجاد می‌کنند و بخش مهمی از فرآیند توسعه باکیفیت هستند.</p>
                        
                </body>
                </html>
            