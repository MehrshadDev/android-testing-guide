
                <!DOCTYPE html>
                <html lang="fa" dir="rtl">
                <head>
                    <meta charset="UTF-8">
                    <meta name="viewport" content="width=device-width, initial-scale=1.0">
                    <title>تست‌های پیشرفته اندروید: Hilt Testing، تست Repository و End-to-End</title>
                    <link href="https://fonts.googleapis.com/css2?family=Vazirmatn:wght@100..900&display=swap" rel="stylesheet">
                    <style>
                        body {
                            font-family: 'Vazirmatn', sans-serif;
                            line-height: 1.8;
                            padding: 2rem;
                            max-width: 900px;
                            margin: 0 auto;
                            color: #333;
                            text-align: justify;
                        }
                        h1, h2, h3 {
                            border-bottom: 2px solid #a7f3d0;
                            padding-bottom: 0.5rem;
                            margin-top: 2.5rem;
                            margin-bottom: 1.5rem;
                            color: #047857;
                            text-align: right;
                        }
                        h1 { font-size: 2rem; }
                        h2 { font-size: 1.75rem; }
                        h3 { font-size: 1.5rem; }
                        p { margin-bottom: 1rem; }
                        pre {
                            background-color: #f4f4f4;
                            border: 1px solid #ddd;
                            padding: 1rem;
                            border-radius: 4px;
                            overflow-x: auto;
                            direction: ltr;
                            text-align: left;
                            font-size: 0.9rem;
                            font-family: monospace;
                        }
                        ul, ol {
                            margin-right: 1.5rem;
                            padding-right: 0;
                            margin-bottom: 1rem;
                        }
                        ul li { list-style-type: disc; margin-bottom: 0.5rem; }
                        strong { color: #065f46; }
                        .document-title { 
                            text-align: center; 
                            margin-bottom: 3rem; 
                            color: #059669;
                            font-size: 2.5rem;
                            font-weight: 800;
                        }
                    </style>
                </head>
                <body>
                    <nav>
                          <a href="index.html">صفحه اصلی</a> |
                          <a href="2.html">مقاله شماره ۲</a> |
                          <a href="3.html">مقاله شماره ۳</a> |
                          <a href="4.html">مقاله شماره ۴</a>
                    </nav>
                    <div class="document-title">تست‌های پیشرفته اندروید: Hilt Testing، تست Repository و End-to-End</div>
                    
                            <p>تست‌های پیشرفته اندروید: Hilt Testing، تست Repository و End-to-End<br>===================================================================</p><p>در مسیر توسعه اپلیکیشن‌های اندرویدی با معماری مدرن (MVI) و استفاده از ابزارهایی مانند Jetpack Compose و Hilt، نوشتن تست‌های جامع صرفاً به Unit Test محدود نمی‌شود. برای اطمینان از صحت عملکرد لایه‌های میانی و فوقانی اپلیکیشن، نیاز به استفاده از تست‌های یکپارچه‌سازی (Integration Tests) و تست‌های سرتاسری (End-to-End) داریم.</p><p>این مقاله به صورت جامع و عمیق، به بررسی سه حوزه کلیدی در تست‌نویسی پیشرفته اندروید می‌پردازد که برای توسعه‌دهندگان حرفه‌ای ضروری است: تست‌نویسی با Hilt، تست لایه Repository، و تست‌های سرتاسری UI.</p><p>---</p><p></p><h2>۱. تست‌نویسی با Hilt: مدیریت تزریق وابستگی در محیط تست</h2><p></p><p>Hilt به عنوان ابزار استاندارد تزریق وابستگی (Dependency Injection) در اندروید، به شدت فرآیند توسعه را ساده می‌کند. با این حال، تست‌نویسی در محیطی که Hilt فعال است، نیازمند یک چارچوب‌بندی (Setup) خاص است تا بتوانیم وابستگی‌های واقعی (Production) را با وابستگی‌های جعلی (Fake) یا شبیه‌سازی‌شده (Mock) جایگزین کنیم.</p><p></p><h3>چالش اصلی Hilt Testing</h3><p></p><p>در یک محیط تست، ما نمی‌خواهیم Hilt از گراف وابستگی‌های تولیدی استفاده کند (مثلاً به دیتابیس واقعی یا سرور شبکه وصل شود). ما نیاز داریم:</p><p><br></p><ul><br><li> Hilt بداند که در حال اجرای تست هستیم.</li><p></p><p></p><li> قابلیت جایگزینی ماژول‌های تولیدی با ماژول‌های تستی را داشته باشیم.</li><p></p><p></p><li> بتوانیم کلاس‌هایی مانند ViewModel یا Activity را که توسط Hilt مدیریت می‌شوند، به درستی تست کنیم.</li><p></p><p></p><h3>۱.۱. پیکربندی محیط تست</h3><p></p><p>برای استفاده از Hilt در تست‌های ابزاری (Instrumented Tests)، باید وابستگی‌های زیر را در فایل <code>build.gradle</code> ماژول مربوطه اضافه کنید:</p><p></p><pre><code class="language-gradle">dependencies {<br>    // Hilt Testing<br>    androidTestImplementation("com.google.dagger:hilt-android-testing:$hilt_version")<br>    kaptAndroidTest("com.google.dagger:hilt-android-compiler:$hilt_version")<br>}</code></pre><p></p><p></p><h3>۱.۲. استفاده از Test Runner سفارشی</h3><p></p><p>Hilt برای مدیریت چرخه حیات تست‌ها و اطمینان از تزریق صحیح، نیازمند یک <code>Application</code> سفارشی و در نتیجه یک <code>TestRunner</code> سفارشی است.</p><p><strong>گام ۱: تعریف Test Runner</strong></p><p>در پوشه <code>androidTest</code>، یک کلاس <code>AndroidJUnitRunner</code> سفارشی تعریف کنید:</p><p></p><pre><code class="language-kotlin">// Example: CustomTestRunner.kt<br>class HiltTestRunner : AndroidJUnitRunner() {<br>    override fun newApplication(cl: ClassLoader?, name: String?, context: Context?): Application {<br>        // نام اپلیکیشن Hilt مخصوص تست را تعیین می‌کنیم<br>        return super.newApplication(cl, "com.yourpackage.HiltTestApplication_Application", context)<br>    }<br>}</code></pre><p></p><p><strong>گام ۲: اعمال Test Runner در پیکربندی Gradle</strong></p><p>در فایل <code>build.gradle</code> سطح ماژول، <code>testInstrumentationRunner</code> را به کلاس سفارشی تعریف شده تغییر دهید:</p><p></p><pre><code class="language-gradle">android {<br>    defaultConfig {<br>        // ...<br>        testInstrumentationRunner "com.yourpackage.HiltTestRunner"<br>    }<br>}</code></pre><p></p><p></p><h3>۱.۳. نوشتن تست‌های Hilt</h3><p></p><p>هر تستی که نیاز به تزریق Hilt دارد، باید دارای شرایط زیر باشد:</p><p><br></p><li> اعمال حاشیه‌نویسی <code>@HiltAndroidTest</code> روی کلاس تست.</li><p></p><p></p><li> استفاده از <code>HiltAndroidRule</code> برای مدیریت تزریق در طول تست.</li><p></p><p><strong>مثال: تست یک ViewModel</strong></p><p>فرض کنید ما یک <code>ViewModel</code> داریم که یک <code>Repository</code> را تزریق می‌کند.</p><p></p><pre><code class="language-kotlin">@HiltAndroidTest<br>class MyViewModelTest {<p></p><p>    // قاعده اصلی Hilt برای مدیریت تزریق‌ها<br>    @get:Rule<br>    var hiltRule = HiltAndroidRule(this)</p><p>    // تزریق مستقیم کلاسی که می‌خواهیم تست کنیم (مثلاً یک Factory)<br>    // یا تزریق وابستگی‌هایی که ViewModel ما به آن نیاز دارد<br>    @Inject<br>    lateinit var viewModel: MyViewModel // یا UseCase مورد نظر</p><p>    @Before<br>    fun setup() {<br>        // تزریق کردن فیلدها توسط Hilt<br>        hiltRule.inject()<br>    }</p></code><p><code class="language-kotlin">    @Test<br>    fun testLoadingData_success() {<br>        // ... اجرای متدهای ViewModel و بررسی وضعیت (State)<br>    }<br>}</code></p></pre><p></p><p></p><h3>۱.۴. جایگزینی ماژول‌ها (<code>@UninstallModules</code>)</h3><p></p><p>اگر بخواهید یک وابستگی خاص (مانند <code>NetworkService</code> یا <code>Database</code>) را با پیاده‌سازی جعلی در محیط تست جایگزین کنید، از حاشیه‌نویسی <code>@UninstallModules</code> و تعریف یک ماژول تستی جدید استفاده می‌کنید:</p><p><br></p><li> <strong>ماژول تولیدی:</strong></li><p></p><p>    </p><pre><code class="language-kotlin">@Module<br>    @InstallIn(SingletonComponent::class)<br>    object AppModule {<br>        @Provides<br>        fun provideRepository(api: MyApi): MyRepository = RealMyRepository(api)<br>    }</code></pre><p></p><p><br></p><li> <strong>ماژول تستی (تعریف شده در پوشه <code>androidTest</code>):</strong></li><p></p><p>    </p><pre><code class="language-kotlin">@Module<br>    @InstallIn(SingletonComponent::class)<br>    object TestAppModule {<br>        // این FakeRepository را برای تست استفاده می‌کنیم<br>        @Provides<br>        fun provideTestRepository(): MyRepository = FakeMyRepository()<br>    }</code></pre><p></p><p><br></p><li> <strong>کلاس تست:</strong></li><p></p><p>    </p><pre><code class="language-kotlin">@HiltAndroidTest<br>    @UninstallModules(AppModule::class) // ماژول تولیدی را حذف می‌کنیم<br>    class MyScreenTest {<br>        // Hilt اکنون به طور خودکار از TestAppModule استفاده می‌کند<br>        // ...<br>    }</code></pre><p></p><p>این رویکرد تضمین می‌کند که در هنگام اجرای تست‌های ابزاری، وابستگی‌ها به شکل کنترل‌شده و پیش‌بینی‌شده‌ای تزریق می‌شوند.</p><p>---</p><p></p><h2>۲. تست لایه Repository: یکپارچه‌سازی داده‌ها (Data Integration)</h2><p></p><p>لایه Repository وظیفه هماهنگی بین منابع داده (Local Data Source مانند Room و Remote Data Source مانند API) را بر عهده دارد. تست این لایه اغلب یک تست یکپارچه‌سازی است، نه یک Unit Test خالص. هدف ما تأیید منطق انتخاب منبع داده، کش کردن، و مدیریت خطا است.</p><p></p><h3>ابزارهای حیاتی: Room Testing و MockWebServer</h3><p></p><p>#### ۲.۱. تست دیتابیس محلی (Room)</p><p>برای تست کردن منطق دیتابیس در Repository، باید از یک دیتابیس موقت و در حافظه (In-Memory Database) استفاده کنیم تا تست‌ها سریع و ایزوله باشند.</p><p><strong>نکات کلیدی برای تست Room:</strong></p><p><br></p><li> <strong>استفاده از دیتابیس In-Memory:</strong> دیتابیس را در حافظه ایجاد کنید تا پس از اتمام تست از بین برود.</li><p></p><p></p><li> <strong>استفاده از <code>TestRule</code>:</strong> برای مدیریت ایجاد و بسته شدن دیتابیس در طول تست.</li><p></p><p></p><pre><code class="language-kotlin">// مثال پیکربندی دیتابیس تستی<br>@RunWith(AndroidJUnit4::class)<br>class MyDaoTest {<br>    private lateinit var database: AppDatabase<br>    private lateinit var dao: MyDao<p></p><p>    @Before<br>    fun setup() {<br>        database = Room.inMemoryDatabaseBuilder(<br>            ApplicationProvider.getApplicationContext(),<br>            AppDatabase::class.java<br>        ).allowMainThreadQueries().build() // allowMainThreadQueries برای تست‌ها مناسب است<br>        dao = database.myDao()<br>    }</p><p>    @After<br>    fun teardown() {<br>        database.close()<br>    }</p></code><p><code class="language-kotlin">    @Test<br>    fun insertAndReadItem_success() = runBlocking {<br>        val item = Item(id = 1, name = "Test Item")<br>        dao.insert(item)<br>        val retrievedItem = dao.getItem(1)<br>        Truth.assertThat(retrievedItem).isEqualTo(item)<br>    }<br>}</code></p></pre><p></p><p>#### ۲.۲. شبیه‌سازی API با MockWebServer</p><p>برای تست سناریوهای شبکه (مانند موفقیت‌آمیز بودن فراخوانی، مدیریت کد خطای 404، یا تأخیر شبکه)، ابزار طلایی استفاده از <strong>MockWebServer</strong> از Square است. این ابزار به ما اجازه می‌دهد یک سرور HTTP محلی راه‌اندازی کرده و پاسخ‌های دلخواه را در صف قرار دهیم.</p><p><strong>فرایند تست Repository با MockWebServer:</strong></p><p><br></p><li> <strong>راه‌اندازی سرور:</strong> سرور MockWebServer را در <code>@Before</code> اجرا کنید.</li><p></p><p></p><li> <strong>تزریق URL سرور:</strong> آدرس IP و پورت MockWebServer را به کلاینت شبکه (مانند Retrofit) تزریق کنید تا درخواست‌ها به جای سرور واقعی، به این سرور محلی ارسال شوند.</li><p></p><p></p><li> <strong>تعریف پاسخ‌ها (Enqueue):</strong> پاسخ‌های JSON یا خطا را که سرور باید برگرداند، در صف قرار دهید.</li><p></p><p></p><li> <strong>اجرای متد Repository:</strong> متد Repository را فراخوانی کنید.</li><p></p><p></p><li> <strong>تأیید نتایج:</strong> بررسی کنید که Repository داده‌های مورد انتظار را بازگردانده و همچنین بررسی کنید که آیا Repository دیتابیس محلی را به‌روز کرده است یا خیر (اگر منطق کش داشته باشد).</li><p></p><p><strong>مثال ساختار تست MockWebServer:</strong></p><p></p><pre><code class="language-kotlin">@HiltAndroidTest<br>@UninstallModules(NetworkModule::class) // فرض می‌کنیم NetworkModule آدرس واقعی API را می‌دهد<br>class DataRepositoryIntegrationTest {<p></p><p>    private lateinit var mockWebServer: MockWebServer<br>    private lateinit var repository: MyRepository</p><p>    @Before<br>    fun setup() {<br>        mockWebServer = MockWebServer()<br>        mockWebServer.start(8080)</p><p>        // ۱. تزریق کردن کلاینت شبکه با آدرس MockWebServer<br>        val apiService = Retrofit.Builder()<br>            .baseUrl(mockWebServer.url("/")) // استفاده از URL سرور Mock<br>            // ... تنظیمات دیگر<br>            .build()<br>            .create(MyApi::class.java)</p><p>        // ۲. ساخت Repository با Fake Database و Mock API<br>        val fakeDao = FakeMyDao() // برای ایزوله نگه داشتن تست دیتابیس<br>        repository = RealMyRepository(apiService, fakeDao)</p><p>        hiltRule.inject()<br>    }</p><p>    @After<br>    fun tearDown() {<br>        mockWebServer.shutdown()<br>    }</p><p>    @Test<br>    fun fetchData_onSuccess_cachesData() = runBlocking {<br>        // ۳. تعریف پاسخ موفقیت‌آمیز<br>        val successResponse = MockResponse()<br>            .setResponseCode(200)<br>            .setBody("{\"data\": \"some data\"}")<br>        mockWebServer.enqueue(successResponse)</p><p>        // ۴. اجرای متد Repository<br>        val result = repository.fetchDataFromServer()</p></code><p><code class="language-kotlin">        // ۵. تأیید: Repository داده صحیح را برگردانده و آن را در کش ذخیره کرده است<br>        Truth.assertThat(result).isNotNull()<br>        // تأیید ذخیره شدن در FakeDao<br>        Truth.assertThat(fakeDao.isCached).isTrue()<br>    }<br>}</code></p></pre><p></p><p>این سطح از تست، منطق پیچیده Repository، شامل مدیریت Race Condition‌ها یا منطق "اول کش را چک کن، بعد شبکه" را با اطمینان کامل پوشش می‌دهد.</p><p>---</p><p></p><h2>۳. تست‌های سرتاسری (End-to-End/E2E): شبیه‌سازی جریان کاربر</h2><p></p><p>تست‌های سرتاسری یا Integration UI، بالاترین سطح هرم تست را تشکیل می‌دهند. این تست‌ها شبیه‌سازی می‌کنند که کاربر نهایی چگونه با اپلیکیشن تعامل می‌کند، از صفحه ورود تا مشاهده نهایی یک داده.</p><p>در معماری MVI، هدف E2E این است که تأیید کنیم وقتی یک <strong>Intent</strong> توسط کاربر ارسال می‌شود، View به درستی به <strong>State</strong> جدید واکنش نشان می‌دهد.</p><p></p><h3>۳.۱. ایزوله‌سازی E2E با استفاده از Hilt</h3><p></p><p>برای اینکه تست‌های E2E سریع و قابل اعتماد باشند، ما باید لایه‌های خارجی (شبکه و دیتابیس) را Mock کنیم، اما همچنان از مسیر واقعی اجرای کد (Use Case، ViewModel، Activity/Compose Screen) استفاده کنیم. Hilt این کار را با قابلیت جایگزینی ماژول‌ها برای ما آسان می‌کند.</p><p>#### گام ۱: تعریف پیاده‌سازی‌های جعلی برای Repository</p><p>در پوشه <code>androidTest</code>، پیاده‌سازی‌هایی از Repository تعریف کنید که همیشه داده‌های از پیش تعیین شده را برمی‌گردانند، بدون نیاز به شبکه یا دیتابیس واقعی.</p><p></p><pre><code class="language-kotlin">// FakeRepository.kt (در پوشه androidTest)<br>class FakeSuccessRepository : MyRepository {<br>    override suspend fun fetchData(): Result<data> {<br>        return Result.success(Data(value = "Data from Fake Repository"))<br>    }<br>    // ...<br>}</data></code></pre><p></p><p>#### گام ۲: تعریف ماژول تستی و استفاده از آن</p><p>از همان تکنیک <code>@UninstallModules</code> که در بخش Hilt توضیح داده شد، برای جایگزینی ماژول <code>Repository</code> واقعی با <code>FakeRepository</code> استفاده کنید.</p><p>#### گام ۳: نوشتن تست E2E با Jetpack Compose</p><p>در تست‌های سرتاسری مبتنی بر Compose، ما از <code>ComposeTestRule</code> استفاده می‌کنیم. این تست‌ها شامل تعامل با عناصر UI و تأیید وضعیت‌های بصری هستند.</p><p></p><pre><code class="language-kotlin">@HiltAndroidTest<br>@UninstallModules(AppModule::class) // جایگزینی ماژول‌ها<br>class HomeScreenE2ETest {<p></p><p>    @get:Rule(order = 0)<br>    var hiltRule = HiltAndroidRule(this)</p><p>    @get:Rule(order = 1)<br>    val composeTestRule = createAndroidComposeRule<mainactivity>() // شروع Activity</mainactivity></p><p>    @Before<br>    fun setup() {<br>        hiltRule.inject()<br>    }</p><p>    @Test<br>    fun givenSuccessState_dataIsDisplayedCorrectly() {<br>        // ۱. تضمین می‌کنیم که FakeRepository داده موفق را برگرداند.<br>        // (این از طریق تزریق Hilt در setup تضمین شده است.)</p><p>        // ۲. انتظار می‌کشیم تا UI به درستی بارگذاری شود.<br>        composeTestRule.setContent {<br>            // نمایش کامپوزبل اصلی<br>            HomeScreen()<br>        }</p><p>        // ۳. شبیه‌سازی Intent کاربر (در این حالت، فقط انتظار بارگذاری)<br>        // اگر لازم باشد، روی یک دکمه کلیک می‌کنیم:<br>        // composeTestRule.onNodeWithText("Load Button").performClick()</p><p>        // ۴. تأیید وضعیت (State Verification)<br>        // بررسی می‌کنیم که متنی که FakeRepository برگردانده، نمایش داده شده باشد.<br>        composeTestRule.onNodeWithText("Data from Fake Repository")<br>            .assertExists("متن مورد انتظار باید روی صفحه نمایش داده شود.")<br>    }</p><p>    @Test<br>    fun givenErrorState_errorMessageIsDisplayed() {<br>        // برای این تست باید FakeRepository را برای برگرداندن خطا تنظیم کنیم.<br>        // (نکته: در سناریوهای پیچیده‌تر، نیاز به یک FakeRepository قابل تنظیم داریم.)</p><p>        // شبیه‌سازی کلیک روی دکمه‌ای که خطا می‌دهد.<br>        // composeTestRule.onNodeWithText("Retry").performClick()</p></code><p><code class="language-kotlin">        // تأیید نمایش پیام خطا<br>        composeTestRule.onNodeWithText("Error loading data")<br>            .assertIsDisplayed()<br>    }<br>}</code></p></pre><p></p><p></p><h3>۳.۲. مزیت تست‌های E2E در MVI</h3><p></p><p>در معماری MVI، تست‌های سرتاسری بسیار قدرتمند هستند زیرا:</p><p>*   <strong>تأیید کامل چرخه حیات:</strong> از View (Compose) تا ViewModel و Use Case و Repository (Fake)، کل مسیر اجرای برنامه تأیید می‌شود.<br>*   <strong>تمرکز بر رفتار کاربر:</strong> تست‌ها به جای جزئیات پیاده‌سازی، بر روی قابلیت استفاده (Usability) و جریان (Flow) برنامه تمرکز می‌کنند.<br>*   <strong>اعتماد به Map شدن State:</strong> تضمین می‌کنند که وقتی ViewModel یک State جدید منتشر می‌کند، Compose View آن را به درستی به عناصر بصری Map می‌کند.</p><p></p><h2>نتیجه‌گیری: هرم تست پیشرفته</h2><p></p><p>توسعه‌دهندگان مدرن اندروید باید فراتر از Unit Testهای ساده فکر کنند. با استفاده از Hilt، ابزارهایی مانند MockWebServer و چارچوب‌های تست UI پیشرفته (Compose Testing)، می‌توانیم یک هرم تست قوی ایجاد کنیم که شامل:</p><p><br></p><li> <strong>Unit Tests:</strong> سریع، ایزوله، برای منطق تجاری (Business Logic) و ViewModel.</li><p></p><p></p><li> <strong>Integration Tests (Repository/Data Layer):</strong> تأیید صحت جریان داده‌ها و منطق کش کردن، با استفاده از دیتابیس‌های In-Memory و MockWebServer.</li><p></p><p></p><li> <strong>End-to-End Tests (UI Layer):</strong> شبیه‌سازی تعاملات کاربر، با استفاده از پیاده‌سازی‌های جعلی Hilt برای ایزوله‌سازی از شبکه/دیتابیس واقعی، و تأیید وضعیت‌های بصری در Jetpack Compose.</li><br></ul><p></p><p>اجرای این تست‌های پیشرفته، نه تنها کیفیت کد را افزایش می‌دهد، بلکه فرآیند Refactoring را بدون ترس از شکستن قابلیت‌های موجود، ممکن می‌سازد.</p>
                        
                </body>
                </html>
            