
                <!DOCTYPE html>
                <html lang="fa" dir="rtl">
                <head>
                    <meta charset="UTF-8">
                    <meta name="viewport" content="width=device-width, initial-scale=1.0">
                    <title>تست‌های واحد محلی (Unit Test): منطق View Model، Coroutines و Mocking</title>
                    <link href="https://fonts.googleapis.com/css2?family=Vazirmatn:wght@100..900&display=swap" rel="stylesheet">
                    <style>
                        body {
                            font-family: 'Vazirmatn', sans-serif;
                            line-height: 1.8;
                            padding: 2rem;
                            max-width: 900px;
                            margin: 0 auto;
                            color: #333;
                            text-align: justify;
                        }
                        h1, h2, h3 {
                            border-bottom: 2px solid #a7f3d0;
                            padding-bottom: 0.5rem;
                            margin-top: 2.5rem;
                            margin-bottom: 1.5rem;
                            color: #047857;
                            text-align: right;
                        }
                        h1 { font-size: 2rem; }
                        h2 { font-size: 1.75rem; }
                        h3 { font-size: 1.5rem; }
                        p { margin-bottom: 1rem; }
                        pre {
                            background-color: #f4f4f4;
                            border: 1px solid #ddd;
                            padding: 1rem;
                            border-radius: 4px;
                            overflow-x: auto;
                            direction: ltr;
                            text-align: left;
                            font-size: 0.9rem;
                            font-family: monospace;
                        }
                        ul, ol {
                            margin-right: 1.5rem;
                            padding-right: 0;
                            margin-bottom: 1rem;
                        }
                        ul li { list-style-type: disc; margin-bottom: 0.5rem; }
                        strong { color: #065f46; }
                        .document-title { 
                            text-align: center; 
                            margin-bottom: 3rem; 
                            color: #059669;
                            font-size: 2.5rem;
                            font-weight: 800;
                        }
                    </style>
                </head>
                <body>
                    <nav>
                          <a href="index.html">صفحه اصلی</a> |
                          <a href="2.html">مقاله شماره ۲</a> |
                          <a href="3.html">مقاله شماره ۳</a> |
                          <a href="4.html">مقاله شماره ۴</a>
                    </nav>
                    <div class="document-title">تست‌های واحد محلی (Unit Test): منطق View Model، Coroutines و Mocking</div>
                    
                            <p></p><h2>تست‌های واحد محلی (Unit Test): منطق View Model، Coroutines و Mocking</h2><p></p><p></p><h3>مقدمه: اهمیت تست واحد در معماری MVI</h3><p></p><p>در برنامه نویسی اندروید مدرن، به‌ویژه هنگام استفاده از معماری MVI (Model-View-Intent) و Jetpack Compose، ViewModel تبدیل به هسته مرکزی منطق تجاری (Business Logic) برنامه می‌شود. تست‌های واحد محلی (Local Unit Tests) سریع‌ترین و مطمئن‌ترین راه برای تأیید این منطق هستند. این تست‌ها بدون نیاز به شبیه‌ساز یا دستگاه اجرا می‌شوند و هدف اصلی آن‌ها بررسی ایزوله‌شده توابع و کلاس‌ها است.</p><p>در یک معماری تمیز (Clean Architecture) با الگوی MVI، ViewModel مسئول دریافت رویدادها (Events)، تعامل با Use Cases (که خود با Repositoryها در ارتباط‌اند) و در نهایت، به‌روزرسانی وضعیت (State) قابل مشاهده برای رابط کاربری است. برای موفقیت‌آمیز بودن تست‌های واحد، باید بتوانیم این کلاس‌ها را کاملاً از وابستگی‌های خارجی (مانند دیتابیس، شبکه یا دیسپچرهای واقعی Coroutine) جدا کنیم.</p><p>---</p><p></p><h3>تنظیمات اولیه و وابستگی‌ها</h3><p></p><p>برای شروع تست‌های واحد پیشرفته در محیط Kotlin و اندروید، نیازمند افزودن کتابخانه‌های زیر به فایل <code>build.gradle</code> (سطح ماژول) در بخش <code>dependencies</code> هستیم.</p><p>| کتابخانه | کاربرد |<br>| :--- | :--- |<br>| <code>junit</code> | چارچوب اصلی تست |<br>| <code>kotlinx-coroutines-test</code> | مدیریت Coroutineها در محیط تست |<br>| <code>mockk</code> (یا <code>mockito-kotlin</code>) | ابزار قدرتمند Mocking در Kotlin |<br>| <code>core-testing</code> | ابزارهای کمکی برای LiveData (اگر هنوز استفاده می‌شود) |</p><p></p><pre><code class="language-groovy">dependencies {<br>    // JUnit<br>    testImplementation 'junit:junit:4.13.2'<br>    // Coroutines Test<br>    testImplementation "org.jetbrains.kotlinx:kotlinx-coroutines-test:1.7.3"<br>    // Mocking (پیشنهاد مدرن: MockK)<br>    testImplementation "io.mockk:mockk:1.13.8" <p></p></code><p><code class="language-groovy">    // برای LiveData (اگرچه StateFlow ارجح است)<br>    testImplementation "androidx.arch.core:core-testing:2.2.0" <br>}</code></p></pre><p></p><p><strong>توجه:</strong> تمام تست‌های واحد محلی باید در دایرکتوری <code>src/test/java</code> قرار گیرند.</p><p>---</p><p></p><h3>بخش ۱: تست منطق ViewModel (State Flow)</h3><p></p><p>هدف از تست یک ViewModel در MVI، اطمینان از این است که با دریافت یک <code>Intent/Event</code> مشخص، ViewModel به درستی با Use Case تعامل کرده و یک <code>State</code> صحیح را به رابط کاربری منتشر می‌کند.</p><p>#### گام ۱: آماده‌سازی قوانین تست (Test Rules)</p><p>اگرچه در استفاده از <code>StateFlow</code> و <code>SharedFlow</code> وابستگی به <code>LiveData</code> از بین می‌رود، اما باید مطمئن شویم که قوانین مربوط به اجرای تست در محیط اندروید (مانند اجرای فوری وظایف پس‌زمینه) رعایت می‌شوند.</p><p>اگر هنوز از <code>LiveData</code> استفاده می‌کنید، استفاده از <code>InstantTaskExecutorRule</code> ضروری است:</p><p></p><pre><code class="language-kotlin">import androidx.arch.core.executor.testing.InstantTaskExecutorRule<br>// ...<br>@get:Rule<br>val instantTaskExecutorRule = InstantTaskExecutorRule()</code></pre><br>اما در یک پروژه مدرن مبتنی بر Flow، تمرکز اصلی بر روی مدیریت Coroutines خواهد بود که در بخش بعدی توضیح داده می‌شود.<p></p><p>#### گام ۲: تست حالات موفقیت‌آمیز و خطا</p><p>ViewModel باید به درستی از حالت بارگذاری (Loading) به حالت موفقیت (Success) یا خطا (Error) تغییر وضعیت دهد.</p><p>فرض کنید <code>UserViewModel</code> دارای یک <code>StateFlow</code> به نام <code>uiState</code> باشد:</p><p></p><pre><code class="language-kotlin">data class UserUiState(<br>    val isLoading: Boolean = false,<br>    val userList: List<user> = emptyList(),<br>    val error: String? = null<br>)</user></code></pre><p></p><p><strong>ساختار تست ViewModel:</strong></p><p><br></p><ul><br><li> <strong>Given (آماده‌سازی):</strong> Use Case را Mock کنید و نحوه پاسخ‌دهی آن را تعیین کنید.</li><p></p><p></p><li> <strong>When (اجرا):</strong> متد مورد نظر ViewModel (معمولاً ارسال یک Event) را فراخوانی کنید.</li><p></p><p></p><li> <strong>Then (بررسی):</strong> وضعیت نهایی (<code>uiState</code>) را بررسی کنید و مطمئن شوید که به درستی به‌روزرسانی شده است. همچنین، اطمینان حاصل کنید که Use Case دقیقاً یک بار فراخوانی شده است.</li><p></p><p><strong>نکته کلیدی:</strong> هنگام تست <code>StateFlow</code>، باید از ابزارهای خاصی برای جمع‌آوری (Collecting) مقادیر استفاده کنیم، یا به سادگی <code>value</code> نهایی <code>StateFlow</code> را پس از اتمام اجرای Coroutine بررسی کنیم.</p><p>---</p><p></p><h3>بخش ۲: مدیریت همزمانی (Coroutines) و زمان‌بندی مجازی</h3><p></p><p>یکی از بزرگ‌ترین چالش‌ها در تست‌های واحد اندروید، مدیریت توابع تعلیق‌پذیر (<code>suspend</code>) و دیسپچرهای Coroutine (مانند <code>Dispatchers.IO</code> یا <code>Dispatchers.Default</code>) است. در محیط تست محلی، این دیسپچرها وجود ندارند و اجرای آن‌ها باعث شکست یا کندی تست می‌شود.</p><p>#### ابزارهای حل مشکل: runTest و Test Dispatcher</p><p>کتابخانه <code>kotlinx-coroutines-test</code> دو ابزار حیاتی را فراهم می‌کند:</p><p><br></p><li> <strong><code>TestDispatcher</code>:</strong> یک پیاده‌سازی مصنوعی از دیسپچرها که امکان کنترل زمان و اجرای آنی را فراهم می‌کند.</li><p></p><p></p><li> <strong><code>runTest</code>:</strong> تابعی که محیط Coroutine را راه‌اندازی می‌کند، تمام Coroutineهای تحت <code>TestDispatcher</code> را به صورت خودکار اجرا می‌کند و پس از اتمام آن‌ها منتظر می‌ماند تا تست به پایان برسد.</li><p></p><p>#### اصل تزریق دیسپچر (Dispatcher Injection)</p><p>برای اینکه ViewModel قابل تست باشد، نباید دیسپچرها را به صورت سخت‌کد شده درون کلاس تعریف کنیم. در عوض، باید آن‌ها را از طریق سازنده (Constructor) تزریق کنیم.</p><p><strong>ViewModel قابل تست:</strong></p><p></p><pre><code class="language-kotlin">// ViewModel (کد تولیدی)<br>class MyViewModel(<br>    private val useCase: MyUseCase,<br>    private val dispatcher: CoroutineDispatcher = Dispatchers.Main // یا Dispatchers.IO<br>) : ViewModel() {<br>    fun fetchData() = viewModelScope.launch(dispatcher) {<br>        // ... منطق فراخوانی Use Case<br>    }<br>}</code></pre><p></p><p><strong>پیاده‌سازی در تست:</strong></p><p></p><pre><code class="language-kotlin">import kotlinx.coroutines.test.runTest<br>import kotlinx.coroutines.test.StandardTestDispatcher<p></p><p>class MyViewModelTest {<br>    // 1. تعریف دیسپچر تست<br>    private val testDispatcher = StandardTestDispatcher()<br>    // 2. ساخت ViewModel با دیسپچر تست<br>    private lateinit var viewModel: MyViewModel<br>    private val mockUseCase: MyUseCase = mockk() <br>    @Before<br>    fun setup() {<br>        viewModel = MyViewModel(mockUseCase, testDispatcher)<br>    }</p></code><p><code class="language-kotlin">    @Test<br>    fun <code>fetchData should update state to success when use case succeeds</code>() = runTest(testDispatcher) {<br>        // Given<br>        coEvery { mockUseCase.execute() } returns Result.success(listOf(User("Alice")))<br>        // When<br>        viewModel.fetchData()<br>        // مهم: اگر از delay یا بافرهای داخلی استفاده می‌کنید، این متد زمان را به جلو می‌برد.<br>        // testDispatcher.scheduler.advanceUntilIdle() <br>        // Then<br>        assertEquals(false, viewModel.uiState.value.isLoading)<br>        assertEquals(1, viewModel.uiState.value.userList.size)<br>    }<br>}</code></p></pre><p></p><p><strong>مزیت <code>runTest</code>:</strong> این تابع تضمین می‌کند که تمامی <code>suspend</code> functionهایی که توسط <code>testDispatcher</code> آغاز شده‌اند، قبل از پایان تست تکمیل شوند. دیگر نیازی به استفاده دستی از <code>advanceUntilIdle()</code> در اکثر سناریوها نیست، مگر اینکه صریحاً نیاز به تست زمان‌بندی‌های پیچیده داشته باشید.</p><p>---</p><p></p><h3>بخش ۳: ایزوله‌سازی و Mocking با MockK</h3><p></p><p>برای اجرای تست واحد واقعی، باید مطمئن شویم که فقط منطق کلاس مورد نظر (مثلاً ViewModel) را تست می‌کنیم، نه وابستگی‌های آن (مانند Use Case یا Repository). اینجاست که Mocking وارد عمل می‌شود.</p><p>#### Mocking چیست؟</p><p><strong>Mock Object (شیء ساختگی):</strong> یک شیء تقلبی است که رفتار یک شیء واقعی را شبیه‌سازی می‌کند.</p><p>*   <strong>Stub:</strong> یک شیء که صرفاً خروجی‌های از پیش تعریف شده را برای متدهای خاص برمی‌گرداند.<br>*   <strong>Mock:</strong> علاوه بر برگرداندن خروجی، امکان ردیابی تعاملات (Verification) را فراهم می‌کند؛ یعنی می‌توانیم بررسی کنیم که آیا یک متد خاص فراخوانی شده است یا خیر، و با چه آرگومان‌هایی.</p><p>#### استفاده از MockK برای Mocking Coroutines</p><p>MockK ابزار ارجح برای Mocking در Kotlin است زیرا از ویژگی‌های زبان مانند <code>extension functions</code> و <code>suspend functions</code> به خوبی پشتیبانی می‌کند.</p><p>##### ۱. ساخت Mock</p><p>با استفاده از تابع <code>mockk()</code> شیء مورد نظر را ساختگی می‌کنیم:</p><p></p><pre><code class="language-kotlin">val mockUserRepository: UserRepository = mockk()</code></pre><p></p><p>##### ۲. تعریف رفتار (Stubbing)</p><p>برای توابع عادی از <code>every</code> و برای توابع تعلیق‌پذیر (<code>suspend</code>) از <code>coEvery</code> استفاده می‌کنیم.</p><p><strong>مثال Mocking تابع موفقیت‌آمیز:</strong></p><p></p><pre><code class="language-kotlin">// برای یک تابع suspend که لیستی از کاربران را برمی‌گرداند<br>coEvery { mockUserRepository.getUsers() } returns listOf(User("Eve"))</code></pre><p></p><p><strong>مثال Mocking تابع با خطا:</strong></p><p>اگر بخواهید تست کنید که ViewModel هنگام دریافت خطا از Repository چگونه واکنش نشان می‌دهد:</p><p></p><pre><code class="language-kotlin">coEvery { mockUserRepository.getUsers() } throws IOException("No Network")</code></pre><p></p><p>##### ۳. بررسی تعاملات (Verification)</p><p>پس از اجرای منطق در <code>When</code>، باید مطمئن شویم که وابستگی‌ها به درستی فراخوانی شده‌اند. از توابع <code>verify</code> و <code>coVerify</code> استفاده می‌کنیم.</p><p><strong>مثال Verification:</strong></p><p></p><pre><code class="language-kotlin">// اطمینان از اینکه متد getUsers دقیقا یک بار فراخوانی شده است<br>coVerify(exactly = 1) { mockUserRepository.getUsers() }</code></pre><p></p><p>---</p><p></p><h3>بخش ۴: مثال جامع: تست ViewModel در MVI با MockK و runTest</h3><p></p><p>در این مثال، یک ViewModel ساده که مسئول بارگذاری داده‌ها از یک Use Case است را تست می‌کنیم.</p><p>#### ۱. تعریف ساختار (ViewModel و Use Case)</p><p></p><pre><code class="language-kotlin">// User.kt<br>data class User(val id: Int, val name: String)<p></p><p>// GetUsersUseCase.kt<br>interface GetUsersUseCase {<br>    suspend fun execute(): Result<list<user>&gt;<br>}</list<user></p><p>// UserViewModel.kt<br>class UserViewModel(<br>    private val getUsersUseCase: GetUsersUseCase,<br>    private val dispatcher: CoroutineDispatcher // تزریق دیسپچر<br>) : ViewModel() {</p><p>    private val _state = MutableStateFlow(UserUiState())<br>    val state: StateFlow<useruistate> = _state.asStateFlow()</useruistate></p><p>    init {<br>        fetchUsers()<br>    }</p></code><p><code class="language-kotlin">    private fun fetchUsers() {<br>        viewModelScope.launch(dispatcher) {<br>            _state.value = _state.value.copy(isLoading = true, error = null)<br>            when (val result = getUsersUseCase.execute()) {<br>                is Result.Success -&gt; {<br>                    _state.value = _state.value.copy(<br>                        isLoading = false,<br>                        userList = result.data<br>                    )<br>                }<br>                is Result.Error -&gt; {<br>                    _state.value = _state.value.copy(<br>                        isLoading = false,<br>                        error = result.exception.message<br>                    )<br>                }<br>            }<br>        }<br>    }<br>}</code></p></pre><p></p><p>#### ۲. پیاده‌سازی تست (<code>UserViewModelTest</code>)</p><p></p><pre><code class="language-kotlin">import io.mockk.coEvery<br>import io.mockk.coVerify<br>import io.mockk.mockk<br>import kotlinx.coroutines.test.*<br>import org.junit.Before<br>import org.junit.Test<br>import org.junit.Assert.assertEquals<p></p><p>class UserViewModelTest {</p><p>    // Test Rule برای مدیریت Coroutineها و اجرای runTest<br>    private val testDispatcher = StandardTestDispatcher()</p><p>    private val mockUseCase: GetUsersUseCase = mockk()<br>    private lateinit var viewModel: UserViewModel</p><p>    @Before<br>    fun setup() {<br>        // هر بار قبل از اجرای تست، ViewModel را با دیسپچر تست بسازید<br>        viewModel = UserViewModel(mockUseCase, testDispatcher)<br>    }</p><p>    @Test<br>    fun <code>on ViewModel init, state should change from Loading to Success</code>() = runTest(testDispatcher) {<br>        // Given (آماده‌سازی داده‌های موفقیت‌آمیز)<br>        val expectedUsers = listOf(User(1, "Ali"), User(2, "Sara"))<br>        coEvery { mockUseCase.execute() } returns Result.Success(expectedUsers)</p><p>        // When (فعالیت در سازنده ViewModel انجام می‌شود، نیازی به فراخوانی مجدد نیست)<br>        // اگر تابع دیگری را تست می‌کردیم، در اینجا فراخوانی می‌شد.<br>        // Then (بررسی نهایی وضعیت)<br>        // 1. بررسی تعامل: مطمئن شوید Use Case فراخوانی شده است<br>        coVerify(exactly = 1) { mockUseCase.execute() }<br>        // 2. بررسی وضعیت: اطمینان از بارگذاری صحیح داده‌ها<br>        val finalState = viewModel.state.value<br>        assertEquals(false, finalState.isLoading)<br>        assertEquals(expectedUsers.size, finalState.userList.size)<br>        assertEquals("Ali", finalState.userList.first().name)<br>        assertEquals(null, finalState.error)<br>    }</p><p>    @Test<br>    fun <code>on ViewModel init, state should change from Loading to Error</code>() = runTest(testDispatcher) {<br>        // Given (آماده‌سازی برای شکست)<br>        val errorMessage = "Network Error"<br>        coEvery { mockUseCase.execute() } returns Result.Error(Exception(errorMessage))</p><p>        // When (ViewModel مجدداً در @Before ساخته می‌شود)<br>        // Then<br>        // 1. بررسی تعامل<br>        coVerify(exactly = 1) { mockUseCase.execute() }</p></code><p><code class="language-kotlin">        // 2. بررسی وضعیت: اطمینان از ثبت پیام خطا<br>        val finalState = viewModel.state.value<br>        assertEquals(false, finalState.isLoading)<br>        assertEquals(true, finalState.userList.isEmpty())<br>        assertEquals(errorMessage, finalState.error)<br>    }<br>}</code></p></pre><p></p><p></p><h3>خلاصه و جمع‌بندی</h3><p></p><p>تست‌های واحد محلی، سنگ بنای اطمینان از صحت منطق تجاری در پروژه‌های مدرن اندروید هستند. با اتخاذ روش‌های صحیح:</p><p><br></p><li> <strong>ایزوله‌سازی:</strong> با استفاده از Mocking (ترجیحاً MockK)، وابستگی‌های خارجی (مانند Repositoryها) را از ViewModel جدا می‌کنیم.</li><p></p><p></p><li> <strong>کنترل همزمانی:</strong> با تزریق <code>CoroutineDispatcher</code> و استفاده از تابع <code>runTest</code>، اجرای توابع <code>suspend</code> را در محیط تست تسریع و مدیریت می‌کنیم.</li><p></p><p></p><li> <strong>تست MVI:</strong> تمرکز تست‌ها بر روی بررسی تغییرات حالت (State) در پاسخ به رویدادها (Events) است، نه جزئیات پیاده‌سازی داخلی.</li><br></ul><p></p><p>این رویکرد تضمین می‌کند که منطق اصلی برنامه شما فارغ از پیچیدگی‌های محیط اندروید یا UI، قابل اعتماد و پایدار باقی بماند. در سرفصل‌های بعدی، به سراغ تست‌های پیشرفته‌تر مانند Android Testها و تست Hilt خواهیم رفت.</p>
                        
                </body>
                </html>
            