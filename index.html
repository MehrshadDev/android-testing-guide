
                <!DOCTYPE html>
                <html lang="fa" dir="rtl">
                <head>
                    <meta charset="UTF-8">
                    <meta name="viewport" content="width=device-width, initial-scale=1.0">
                    <title>مبانی تست‌نویسی، اصول کدنویسی تمیز و استراتژی تست MVI</title>
                    <link href="https://fonts.googleapis.com/css2?family=Vazirmatn:wght@100..900&display=swap" rel="stylesheet">
                    <style>
                        body {
                            font-family: 'Vazirmatn', sans-serif;
                            line-height: 1.8;
                            padding: 2rem;
                            max-width: 900px;
                            margin: 0 auto;
                            color: #333;
                            text-align: justify;
                        }
                        h1, h2, h3 {
                            border-bottom: 2px solid #a7f3d0;
                            padding-bottom: 0.5rem;
                            margin-top: 2.5rem;
                            margin-bottom: 1.5rem;
                            color: #047857;
                            text-align: right;
                        }
                        h1 { font-size: 2rem; }
                        h2 { font-size: 1.75rem; }
                        h3 { font-size: 1.5rem; }
                        p { margin-bottom: 1rem; }
                        pre {
                            background-color: #f4f4f4;
                            border: 1px solid #ddd;
                            padding: 1rem;
                            border-radius: 4px;
                            overflow-x: auto;
                            direction: ltr;
                            text-align: left;
                            font-size: 0.9rem;
                            font-family: monospace;
                        }
                        ul, ol {
                            margin-right: 1.5rem;
                            padding-right: 0;
                            margin-bottom: 1rem;
                        }
                        ul li { list-style-type: disc; margin-bottom: 0.5rem; }
                        strong { color: #065f46; }
                        .document-title { 
                            text-align: center; 
                            margin-bottom: 3rem; 
                            color: #059669;
                            font-size: 2.5rem;
                            font-weight: 800;
                        }
                    </style>
                </head>
                <body>
                    <nav>
                          <a href="index.html">صفحه اصلی</a> |
                          <a href="2.html">مقاله شماره ۲</a> |
                          <a href="3.html">مقاله شماره ۳</a> |
                          <a href="4.html">مقاله شماره ۴</a>
                    </nav>
                    <div class="document-title">مبانی تست‌نویسی، اصول کدنویسی تمیز و استراتژی تست MVI</div>
                    
                            <p></p><h1>آموزش تست‌نویسی پیشرفته در اندروید (Jetpack Compose &amp; MVI)</h1><p></p><p></p><h2>سرفصل فعلی: مبانی تست‌نویسی، اصول کدنویسی تمیز و استراتژی تست MVI</h2><p></p><p>---</p><p>به عنوان یک توسعه‌دهنده حرفه‌ای اندروید، تست‌نویسی نه تنها یک مهارت، بلکه یک ضرورت اخلاقی در تولید نرم‌افزار با کیفیت است. در این بخش بنیادین، ما سنگ بنای سفر خود را در دنیای تست‌نویسی اندروید می‌گذاریم. تمرکز ما بر فهم چرایی تست، چگونگی ساختاردهی به کدهای قابل تست (Testable) بر اساس اصول کدنویسی تمیز، و در نهایت، استراتژی بهینه تست برای معماری MVI خواهد بود.</p><p>---</p><p></p><h2>بخش اول: مبانی تست‌نویسی و چرایی آن</h2><p></p><p>تست‌نویسی، فرآیند تأیید (Verification) این موضوع است که آیا بخش‌های مختلف سیستم ما آن‌طور که انتظار می‌رود عمل می‌کنند یا خیر. این فرآیند صرفاً به معنی پیدا کردن باگ نیست؛ بلکه ابزاری قدرتمند برای بهبود طراحی و افزایش اعتماد به نفس توسعه‌دهندگان است.</p><p></p><h3>۱. چرایی تست‌نویسی: مزایای حیاتی</h3><p></p><p><strong>الف. جلوگیری از رگرسیون (Regression Prevention):</strong><br>رگرسیون زمانی اتفاق می‌افتد که یک تغییر جدید (مثلاً افزودن یک قابلیت یا رفع یک باگ) باعث می‌شود قابلیتی که قبلاً کار می‌کرده، از کار بیفتد. تست‌های خودکار مانند یک شبکه ایمنی عمل می‌کنند؛ هرگاه کدی را تغییر دهید، تست‌ها فوراً به شما اطلاع می‌دهند که آیا عملکرد قبلی حفظ شده است یا خیر.</p><p><strong>ب. افزایش اعتماد به نفس و سرعت توسعه:</strong><br>در یک پایگاه کد بزرگ، توسعه‌دهندگان اغلب از دست زدن به بخش‌های قدیمی سیستم واهمه دارند. وجود مجموعه کاملی از تست‌ها، این اطمینان را می‌دهد که تغییرات شما پیامدهای ناخواسته‌ای نخواهند داشت. این امر سرعت توسعه را به طور چشمگیری افزایش می‌دهد.</p><p><strong>ج. طراحی بهتر و ساختاردهی ماژولار:</strong><br>کدی که قابل تست باشد، به طور ذاتی بهتر طراحی شده است. برای نوشتن یک تست مؤثر، شما ناچارید وابستگی‌ها (Dependencies) را از بین ببرید. این فرآیند منجر به ایجاد ماژول‌های کوچک‌تر، مستقل‌تر و با مسئولیت‌های مشخص (Single Responsibility) می‌شود.</p><p></p><h3>۲. هرم تست‌نویسی (The Testing Pyramid)</h3><p></p><p>هرم تست، استراتژی استاندارد صنعت نرم‌افزار برای توزیع انواع تست‌ها است. شکل هرمی نشان‌دهنده نسبت ایده‌آل هر نوع تست از نظر تعداد، سرعت اجرا و هزینه نگهداری است.</p><p>| سطح تست | نوع تست | سرعت | هدف اصلی |<br>| :---: | :---: | :---: | :---: |<br>| <strong>قاعده (پایه)</strong> | <strong>تست‌های واحد (Unit Tests)</strong> | بسیار سریع | تست منطق تجاری (Business Logic) در ایزوله کامل. |<br>| <strong>میانه</strong> | <strong>تست‌های یکپارچه‌سازی (Integration Tests)</strong> | متوسط | تست ارتباط بین ماژول‌ها، پایگاه داده یا APIها. |<br>| <strong>نوک (راس)</strong> | <strong>تست‌های UI/End-to-End</strong> | کُند | تست تجربه کاربری کامل و جریان‌های اصلی اپلیکیشن. |</p><p>در توسعه اندروید مدرن، به ویژه با معماری MVI، بیشترین تلاش و بیشترین تعداد تست‌های شما باید در بخش <strong>تست‌های واحد</strong> متمرکز شود، چرا که این بخش سریع‌ترین، ارزان‌ترین و قابل اعتمادترین راه برای تأیید منطق است.</p><p></p><h3>۳. مفاهیم کلیدی: ایزوله‌سازی و Test Doubles</h3><p></p><p>برای تست کردن یک واحد از کد (مانند یک <code>ViewModel</code>)، باید مطمئن شویم که نتایج تست تحت تأثیر وابستگی‌های خارجی (مانند فراخوانی شبکه یا پایگاه داده) قرار نمی‌گیرند. اینجاست که مفهوم <strong>ایزوله‌سازی (Isolation)</strong> و استفاده از <strong>Test Doubles</strong> مطرح می‌شود.</p><p><strong>Test Doubles (جایگزین‌های تستی):</strong> اشیائی هستند که برای جایگزینی وابستگی‌های واقعی در محیط تست استفاده می‌شوند.</p><p><em>   <strong>Mock (ماک):</strong> شیئی که نه تنها جایگزین وابستگی می‌شود، بلکه انتظار می‌رود (Expectation) فراخوانی‌های خاصی روی آن انجام شود. ماک‌ها برای تأیید </em>تعاملات* بین واحد تحت تست و وابستگی‌هایش استفاده می‌شوند.<br><em>   <strong>Stub (استاب):</strong> شیئی که حداقل پیاده‌سازی لازم را ارائه می‌دهد و پاسخ‌های از پیش تعیین شده را برمی‌گرداند. استاب‌ها برای کنترل </em>داده‌های ورودی* به واحد تحت تست استفاده می‌شوند.<br>*   <strong>Fake (جعلی):</strong> پیاده‌سازی‌های سبک‌تر و ساده‌تری از وابستگی‌های واقعی هستند (مثلاً یک پیاده‌سازی درون حافظه‌ای از یک پایگاه داده).</p><p><strong>مثال کاربردی:</strong><br>اگر در حال تست یک <code>ViewModel</code> هستید که به یک <code>UserRepository</code> وابسته است، شما باید از یک <strong>Mock UserRepository</strong> استفاده کنید تا مطمئن شوید که:<br>۱. وقتی متد <code>loadUser()</code> در <code>ViewModel</code> فراخوانی می‌شود، متد <code>getUserFromRemote()</code> در <code>Mock UserRepository</code> فراخوانی شده است (تأیید تعامل).<br>۲. پاسخ‌هایی را که باید از UserRepository دریافت شود (مثل موفقیت یا شکست) را کنترل کنید (استفاده از Stubbing).</p><p>---</p><p></p><h2>بخش دوم: اصول کدنویسی تمیز برای تسهیل تست</h2><p></p><p>ارتباط بین کدنویسی تمیز (Clean Code) و تست‌نویسی ناگسستنی است. یک کد نامنظم، tightly coupled (شدیداً وابسته به هم) و دارای مسئولیت‌های چندگانه، عملاً قابل تست مؤثر نیست. اصول زیر، پایه‌هایی هستند که به شما اجازه می‌دهند کدهایی بنویسید که تست کردن آن‌ها آسان، سریع و قابل اطمینان باشد.</p><p></p><h3>۱. اصل مسئولیت واحد (Single Responsibility Principle - SRP)</h3><p></p><p>مهم‌ترین اصل برای تست‌نویسی. هر کلاس، ماژول یا تابع باید تنها یک دلیل برای تغییر داشته باشد.</p><p><strong>تأثیر بر تست:</strong> وقتی یک واحد تنها یک مسئولیت دارد، تست آن ساده می‌شود. اگر یک <code>ViewModel</code> هم مسئول منطق نمایش و هم مسئول ذخیره‌سازی داده باشد، برای تست کردن منطق نمایش باید محیط ذخیره‌سازی را نیز فراهم کنید که پیچیدگی تست را بالا می‌برد. با جدا کردن این مسئولیت‌ها، می‌توان هر واحد را به صورت مجزا و ایزوله تست کرد.</p><p></p><h3>۲. تزریق وابستگی (Dependency Injection - DI)</h3><p></p><p>DI فرآیند ارائه وابستگی‌ها به یک شیء است تا آن شیء خودش مجبور به ایجاد وابستگی‌ها نباشد. در اندروید مدرن، کتابخانه‌هایی مانند <strong>Hilt</strong> یا <strong>Koin</strong> این کار را انجام می‌دهند.</p><p><strong>چرا DI برای تست ضروری است؟</strong><br>DI به شما امکان می‌دهد که در زمان تست، وابستگی‌های واقعی (Real Dependencies) را با Test Doubles (Mockها و Stubها) جایگزین کنید.</p><p>اگر ViewModel شما به شکل زیر باشد:</p><p><strong>کد غیرقابل تست (وابستگی سخت):</strong><br></p><pre><code class="language-kotlin">class UserViewModel {<br>    private val repository = UserRepository() // خود ViewModel تصمیم می‌گیرد آن را بسازد!<br>    // ...<br>}</code></pre><br>در این حالت، هیچ راهی ندارید جز اینکه همیشه از <code>UserRepository</code> واقعی استفاده کنید.<p></p><p><strong>کد قابل تست (با استفاده از DI):</strong><br></p><pre><code class="language-kotlin">// وابستگی از طریق سازنده تزریق می‌شود.<br>class UserViewModel(private val repository: UserRepository) { <br>    // ...<br>}</code></pre><br>حالا در تست، می‌توانیم یک <code>MockUserRepository</code> را به سازنده این ViewModel تزریق کرده و رفتار آن را کاملاً کنترل کنیم.<p></p><p></p><h3>۳. ویژگی‌های یک تست خوب (F.I.R.S.T)</h3><p></p><p>F.I.R.S.T مجموعه‌ای از قوانین است که کیفیت و نگهداری تست‌های شما را تضمین می‌کند:</p><p>| حرف | مفهوم | توضیح |<br>| :---: | :---: | :---: |<br>| <strong>F</strong> | <strong>Fast (سریع)</strong> | تست‌ها باید سریع اجرا شوند. اگر صدها تست چند دقیقه طول بکشند، توسعه‌دهنده از اجرای آن‌ها صرف نظر می‌کند. این به معنای اجتناب از وابستگی‌های خارجی کُند است. |<br>| <strong>I</strong> | <strong>Isolated (ایزوله)</strong> | هر تست باید کاملاً مستقل از تست‌های دیگر باشد. ترتیب اجرای تست‌ها نباید بر نتیجه تأثیر بگذارد. |<br>| <strong>R</strong> | <strong>Repeatable (تکرارپذیر)</strong> | اجرای یک تست در هر زمان و در هر محیطی (مثلاً لپ‌تاپ شما یا سرور CI/CD) باید همیشه نتیجه یکسان بدهد. (اجتناب از استفاده از زمان یا داده‌های تصادفی). |<br>| <strong>S</strong> | <strong>Self-Validating (خود تأییدگر)</strong> | تست باید بتواند نتیجه را به وضوح اعلام کند (بگذرد یا رد شود) و نیاز به بررسی دستی لاگ‌ها نداشته باشد. |<br>| <strong>T</strong> | <strong>Timely (به موقع)</strong> | تست‌ها باید قبل از پیاده‌سازی کدهای تولیدی (Production Code) یا همزمان با آن نوشته شوند (TDD). |</p><p>---</p><p></p><h2>بخش سوم: استراتژی تست معماری MVI (Model-View-Intent)</h2><p></p><p>معماری MVI به دلیل جریان داده تک‌جهته (Unidirectional Data Flow) و تأکید بر حالت (State) غیرقابل تغییر، به طور طبیعی یکی از تست‌پذیرترین معماری‌های موجود برای اندروید است.</p><p>در MVI، منطق تجاری سیستم به وضوح به سه بخش اصلی تقسیم می‌شود که هر کدام استراتژی تست مخصوص به خود را دارند.</p><p></p><h3>۱. درک جریان MVI برای تست</h3><p></p><p>جریان MVI به سادگی به شرح زیر است:</p><p>$$\text{User Action/Event} \rightarrow \text{Intent} \rightarrow \text{ViewModel/Processor} \rightarrow \text{State Change} \rightarrow \text{View/Compose}$$</p><p>هدف اصلی تست‌نویسی در این معماری، تأیید این زنجیره است: <strong>آیا یک Intent مشخص، منجر به تولید State صحیح می‌شود؟</strong></p><p></p><h3>۲. استراتژی تست لایه‌های MVI</h3><p></p><p>#### الف. تست ViewModel (قلب MVI)</p><p>ViewModel در MVI معمولاً به عنوان یک <em>State Reducer</em> عمل می‌کند؛ یعنی مجموعه‌ای از Intentها را دریافت کرده و با ترکیب آن‌ها با State فعلی، یک State جدید را تولید می‌کند. این بخش باید با <strong>تست‌های واحد (Unit Tests)</strong> پوشش داده شود و ۹۰ درصد منطق تست‌نویسی شما در اینجا انجام می‌شود.</p><p><strong>چه چیزهایی را در ViewModel تست کنیم؟</strong></p><p><br></p><ul><br><li> <strong>پردازش Intent و تولید State:</strong> مهم‌ترین بخش. تأیید کنید که پس از ارسال یک Intent (مثلاً <code>Intent.LoadInitialData</code>):</li><br>    *   ابتدا State به <code>Loading</code> تغییر کند.<br>    *   در صورت موفقیت آمیز بودن عملیات زیرین (مثلاً فراخوانی Repository)، State نهایی حاوی داده‌های صحیح باشد.<br>    *   در صورت بروز خطا، State به <code>Error</code> تغییر کند.<p></p><p><br></p><li> <strong>Side Effects (اثرات جانبی):</strong> اگر ViewModel شما Side Effectهایی مانند نمایش Toast، هدایت کاربر یا نمایش دیالوگ صادر می‌کند (که اغلب در MVI برای مدیریت عملیات یکباره استفاده می‌شود)، باید تأیید کنید که در واکنش به Intentها، Side Effectهای صحیح صادر شده‌اند.</li><p></p><p><br></p><li> <strong>رفتار در برابر خطاها:</strong> مطمئن شوید که ViewModel در مواجهه با خطاهایی که از لایه‌های پایین‌تر (مانند Data/Domain) می‌آیند، به درستی واکنش نشان داده و State خطا را منتشر می‌کند.</li><br></ul><p></p><p><strong>ابزارهای کلیدی برای تست ViewModel:</strong><br>*   <strong>JUnit 5/4:</strong> فریم‌ورک اصلی.<br>*   <strong>Mockito/MockK:</strong> برای ایجاد Test Doubles از Repositoryها و Use Caseها.<br>*   <strong>Coroutines Test (کتابخانه <code>kotlinx-coroutines-test</code>):</strong> ضروری برای مدیریت و کنترل اجرای Coroutines و Flowها در ViewModel.</p><p>#### ب. تست لایه Domain (Use Cases/Interactors)</p><p>لایه Domain شامل منطق تجاری خالص (Pure Business Logic) است و هیچ وابستگی به فریم‌ورک‌های اندرویدی ندارد.</p><p><strong>استراتژی تست:</strong><br>*   <strong>Unit Test خالص:</strong> تست‌های این لایه باید سریع‌ترین تست‌های شما باشند.<br>*   <strong>Focus:</strong> تأیید کنید که Use Caseها، وظیفه مشخص خود را (مثل فیلتر کردن، مرتب‌سازی یا تبدیل داده) به درستی انجام می‌دهند.<br>*   <strong>Dependencies:</strong> این لایه به Repository Interfaces وابسته است که باید با Mock کردن آن‌ها، تأیید کنید که Use Case، متدهای صحیح Repository را فراخوانی می‌کند.</p><p>#### ج. تست لایه Data (Repository &amp; Data Sources)</p><p>این لایه واسط بین Domain و داده‌های واقعی (شبکه یا دیتابیس) است.</p><p><strong>استراتژی تست:</strong><br>*   <strong>Repository:</strong> معمولاً با Unit Test تست می‌شود. ما باید تأیید کنیم که Repository به درستی داده‌های دریافتی از Data Sourceها را برای Domain Mapper می‌کند. Data Sources باید Mock شوند.<br>*   <strong>Data Sources:</strong><br>    <em>   </em>Remote Data Source (API):* این بخش معمولاً با تست‌های یکپارچه‌سازی (Integration Tests) یا استفاده از ابزارهایی مانند <strong>MockWebServer</strong> (برای شبیه‌سازی API) تست می‌شود تا مطمئن شویم که فراخوانی‌ها، سریالیزیشن (Serialization) و مدیریت خطاها به درستی کار می‌کند.<br>    <em>   </em>Local Data Source (Room/SQL):* با استفاده از تست‌های یکپارچه‌سازی محلی (با پایگاه داده درون حافظه‌ای یا تست‌های Android Test سبک) تست می‌شود.</p><p>#### د. تست لایه View/UI (Jetpack Compose)</p><p>در MVI، View (یا Composableها در Compose) صرفاً وظیفه تبدیل State دریافتی از ViewModel به عناصر بصری را دارند و هیچ منطق تجاری‌ای نباید در آن‌ها وجود داشته باشد.</p><p><strong>استراتژی تست:</strong><br>*   <strong>Compose Test (Android Test):</strong> استفاده از کتابخانه <code>androidx.compose.ui.test</code>.<br>*   <strong>Focus:</strong> تست UI بر اساس State. به جای تست منطق، باید تأیید کنیم که:<br>    *   اگر <code>State.Loading</code> باشد، انیمیشن بارگذاری نمایش داده می‌شود.<br>    *   اگر <code>State.Success(data)</code> باشد، داده‌های صحیح روی صفحه نشان داده می‌شوند.<br>    *   اگر کاربر دکمه‌ای را لمس کند، Intent یا Event صحیح به ViewModel ارسال می‌شود.</p><p>---</p><p></p><h2>جمع‌بندی بنیادین</h2><p></p><p>ما در این بخش، نقشه راه تست‌نویسی اندروید را بر اساس هرم تست ترسیم کردیم و به اهمیت حیاتی کدنویسی تمیز (به ویژه SRP و DI) برای تولید کدهای قابل تست پرداختیم. همچنین، مشخص کردیم که در معماری MVI، تمرکز اصلی تست ما باید بر روی ViewModel باشد تا اطمینان حاصل کنیم که جریان Intent به State، به صورت قطعی (Deterministic) و صحیح پیش می‌رود.</p><p>در سرفصل‌های بعدی، وارد عمل شده و ابزارها و کدهای لازم برای پیاده‌سازی دقیق Unit Testها، مدیریت Coroutines و نوشتن تست‌های پیشرفته‌تر (شامل Hilt Test) را بررسی خواهیم کرد.</p>
                        
                </body>
                </html>
            